// Owlby-api/lib/api-logger.ts
import { createClient } from '@supabase/supabase-js';
import { MODEL_NAME } from './ai-config';

// Re-using the Supabase client from the web project for consistency
// This assumes that environment variables SUPABASE_URL and SUPABASE_ANON_KEY are available
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

interface APILogData {
  route: 'chat' | 'lesson' | 'story';
  userId?: string;
  chatId?: string;
  gradeLevel: number;
  model: string;
  inputText: string;
  outputText?: string;
  responseTimeMs: number;
  success: boolean;
  error?: string;
  geminiUsageMetadata?: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

interface LogEntry {
  // id is generated by Supabase
  timestamp: string;
  route: string;
  user_id?: string;
  chat_id?: string;
  grade_level: number;
  model: string;
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
  input_length: number;
  output_length: number;
  response_time_ms: number;
  success: boolean;
  error_type?: string;
  exact_cost: number;
}

class APILoggingService {
  private buffer: LogEntry[] = [];
  private readonly BATCH_SIZE = 50;
  private readonly FLUSH_INTERVAL = 30000; // 30 seconds
  private flushTimer: NodeJS.Timeout;
  
  // Running cost tracking for this session
  private sessionStats = {
    totalCost: 0,
    totalInputTokens: 0,
    totalOutputTokens: 0,
    totalCalls: 0,
    startTime: new Date()
  };

  // Gemini pricing per 1M tokens (update as needed)
  // Keys should match model names when possible. Unknown models will fall back
  // to 'gemini-2.5-flash' pricing.
  private readonly PRICING = {
    'gemini-2.5-flash': { input: 0.30, output: 2.50 }
  } as const;
  
  constructor() {
    this.flushTimer = setInterval(() => this.flushToSupabase(), this.FLUSH_INTERVAL);
  }

  async flushNow(): Promise<void> {
    await this.flushToSupabase();
  }

  async logAPICall(data: APILogData): Promise<void> {
    try {
      const configuredModel = data.model || MODEL_NAME;
      const pricingModel: keyof typeof this.PRICING = (configuredModel in this.PRICING
        ? (configuredModel as keyof typeof this.PRICING)
        : 'gemini-2.5-flash');
      const inputTokens = data.geminiUsageMetadata?.promptTokenCount || 0;
      const outputTokens = data.geminiUsageMetadata?.candidatesTokenCount || 0;
      const totalTokens = data.geminiUsageMetadata?.totalTokenCount || 0;
      const exactCost = this.calculateCost(inputTokens, outputTokens, pricingModel);
      
      // DETAILED TOKEN USAGE LOG - Always visible in Vercel logs 
      console.info(`ðŸ’° [${data.route.toUpperCase()}] TOKEN USAGE & COST BREAKDOWN:`, {
        timestamp: new Date().toISOString(),
        route: data.route,
        model: data.model,
        user_id: data.userId?.substring(0, 8) + '...',
        chat_id: data.chatId,
        grade_level: data.gradeLevel,
        success: data.success,
        error: data.error || 'none',
        response_time_ms: data.responseTimeMs,
        
        // TOKEN BREAKDOWN
        tokens: {
          input_tokens: inputTokens,
          output_tokens: outputTokens, 
          total_tokens: totalTokens,
          token_ratio: outputTokens > 0 ? (outputTokens / inputTokens).toFixed(2) : 'N/A'
        },
        
        // TEXT LENGTH ANALYSIS
        text_analysis: {
          input_chars: data.inputText.length,
          output_chars: data.outputText?.length || 0,
          chars_per_input_token: inputTokens > 0 ? (data.inputText.length / inputTokens).toFixed(2) : 'N/A',
          chars_per_output_token: outputTokens > 0 ? ((data.outputText?.length || 0) / outputTokens).toFixed(2) : 'N/A'
        },
        
        // COST BREAKDOWN
        cost_breakdown: {
          input_cost_usd: ((inputTokens / 1_000_000) * this.PRICING[pricingModel].input).toFixed(6),
          output_cost_usd: ((outputTokens / 1_000_000) * this.PRICING[pricingModel].output).toFixed(6),
          total_cost_usd: exactCost.toFixed(6),
          cost_per_1k_tokens: totalTokens > 0 ? ((exactCost / totalTokens) * 1000).toFixed(6) : 'N/A'
        },
        
        // PRICING RATES USED
        pricing_rates: {
          model: pricingModel,
          input_rate_per_1m: `$${this.PRICING[pricingModel].input}`,
          output_rate_per_1m: `$${this.PRICING[pricingModel].output}`,
          output_multiplier: `${(this.PRICING[pricingModel].output / this.PRICING[pricingModel].input).toFixed(1)}x more than input`
        },
        
        // RAW GEMINI METADATA
        raw_gemini_metadata: data.geminiUsageMetadata
      });
      
      // Update session running totals
      this.sessionStats.totalCost += exactCost;
      this.sessionStats.totalInputTokens += inputTokens;
      this.sessionStats.totalOutputTokens += outputTokens;
      this.sessionStats.totalCalls += 1;
      
      // Additional high-level summary for easy scanning
      const costInCents = exactCost * 100;
      const sessionCostInCents = this.sessionStats.totalCost * 100;
      console.info(`ðŸ’¸ [${data.route.toUpperCase()}] COST SUMMARY: $${exactCost.toFixed(6)} (${costInCents.toFixed(3)}Â¢) | ${inputTokens}â†’${outputTokens} tokens | ${data.responseTimeMs}ms`);
      console.info(`ðŸ“Š [SESSION TOTALS] Calls: ${this.sessionStats.totalCalls} | Total Cost: $${this.sessionStats.totalCost.toFixed(6)} (${sessionCostInCents.toFixed(3)}Â¢) | Tokens: ${this.sessionStats.totalInputTokens}â†’${this.sessionStats.totalOutputTokens}`);
      
      const entry: LogEntry = {
        timestamp: new Date().toISOString(),
        route: data.route,
        user_id: data.userId,
        chat_id: data.chatId,
        grade_level: data.gradeLevel,
        model: data.model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        total_tokens: totalTokens,
        input_length: data.inputText.length,
        output_length: data.outputText?.length || 0,
        response_time_ms: data.responseTimeMs,
        success: data.success,
        error_type: data.error,
        exact_cost: exactCost
      };

      this.buffer.push(entry);

      if (this.buffer.length >= this.BATCH_SIZE) {
        await this.flushToSupabase();
      }
    } catch (error) {
      console.error('[API LOGGER] Failed to log API call:', error, data);
      // Logging failures shouldn't break the API
    }
  }

  private calculateCost(inputTokens: number, outputTokens: number, model: keyof typeof this.PRICING): number {
    const rates = this.PRICING[model] || this.PRICING['gemini-2.5-flash'];
    const cost = ((inputTokens / 1_000_000) * rates.input) + ((outputTokens / 1_000_000) * rates.output);
    return cost;
  }

  private async flushToSupabase(): Promise<void> {
    if (this.buffer.length === 0) return;

    const batch = [...this.buffer];
    this.buffer = [];

    try {
      const { error, data } = await supabase.from('api_usage_logs').insert(batch);

      if (error) {
        console.error('[API LOGGER] Supabase insert error:', error, { batch });
        // Re-add to buffer for retry on next flush
        this.buffer.unshift(...batch);
      } else {
        console.info(`ðŸ“Š Logged ${batch.length} API calls to database`);
      }
    } catch (error) {
      console.error('[API LOGGER] Failed to flush logs to Supabase:', error, { batch });
      this.buffer.unshift(...batch);
    }
  }

  destroy(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    this.flushToSupabase(); // Final flush before exit
  }
}

export const apiLogger = new APILoggingService();
export const flushApiLogger = () => apiLogger.flushNow();


// Route-specific helpers for convenience

export const logChatCall = (data: {
    userId?: string;
    chatId: string;
    gradeLevel: number;
    message: string;
    responseText?: string;
    responseTimeMs: number;
    success: boolean;
    error?: string;
    usageMetadata?: any;
    model: string;
  }) => {
    return apiLogger.logAPICall({
      route: 'chat',
      inputText: data.message,
      outputText: data.responseText,
      geminiUsageMetadata: data.usageMetadata,
      ...data
    });
  };
  
  export const logLessonCall = (data: {
    userId?: string;
    gradeLevel: number;
    topic: string;
    responseText?: string;
    responseTimeMs: number;
    success: boolean;
    error?: string;
    usageMetadata?: any;
    model: string;
  }) => {
    return apiLogger.logAPICall({
      route: 'lesson',
      inputText: data.topic,
      outputText: data.responseText,
      geminiUsageMetadata: data.usageMetadata,
      ...data
    });
  };
  
  export const logStoryCall = (data: {
    userId?: string;
    gradeLevel: number;
    prompt: string;
    responseText?: string;
    responseTimeMs: number;
    success: boolean;
    error?: string;
    usageMetadata?: any;
    model: string;
  }) => {
    return apiLogger.logAPICall({
      route: 'story',
      inputText: data.prompt,
      outputText: data.responseText,
      geminiUsageMetadata: data.usageMetadata,
      ...data
    });
  }; 
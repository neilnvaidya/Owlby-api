// Owlby-api/lib/api-logger.ts
import { createClient } from '@supabase/supabase-js';

// Re-using the Supabase client from the web project for consistency
// This assumes that environment variables SUPABASE_URL and SUPABASE_ANON_KEY are available
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

interface APILogData {
  route: 'chat' | 'lesson' | 'story';
  userId?: string;
  chatId?: string;
  gradeLevel: number;
  model: string;
  inputText: string;
  outputText?: string;
  responseTimeMs: number;
  success: boolean;
  error?: string;
  geminiUsageMetadata?: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

interface LogEntry {
  // id is generated by Supabase
  timestamp: string;
  route: string;
  user_id?: string;
  chat_id?: string;
  grade_level: number;
  model: string;
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
  input_length: number;
  output_length: number;
  response_time_ms: number;
  success: boolean;
  error_type?: string;
  exact_cost: number;
}

class APILoggingService {
  private buffer: LogEntry[] = [];
  private readonly BATCH_SIZE = 50;
  private readonly FLUSH_INTERVAL = 30000; // 30 seconds
  private flushTimer: NodeJS.Timeout;

  // Gemini pricing per 1M tokens (update as needed)
  private readonly PRICING = {
    'gemini-2.5-flash': { input: 0.30, output: 2.50 }
  };
  
  constructor() {
    this.flushTimer = setInterval(() => this.flushToSupabase(), this.FLUSH_INTERVAL);
  }

  async logAPICall(data: APILogData): Promise<void> {
    try {
      const modelName = data.model as keyof typeof this.PRICING;
      const entry: LogEntry = {
        timestamp: new Date().toISOString(),
        route: data.route,
        user_id: data.userId,
        chat_id: data.chatId,
        grade_level: data.gradeLevel,
        model: data.model,
        input_tokens: data.geminiUsageMetadata?.promptTokenCount || 0,
        output_tokens: data.geminiUsageMetadata?.candidatesTokenCount || 0,
        total_tokens: data.geminiUsageMetadata?.totalTokenCount || 0,
        input_length: data.inputText.length,
        output_length: data.outputText?.length || 0,
        response_time_ms: data.responseTimeMs,
        success: data.success,
        error_type: data.error,
        exact_cost: this.calculateCost(
          data.geminiUsageMetadata?.promptTokenCount || 0,
          data.geminiUsageMetadata?.candidatesTokenCount || 0,
          modelName
        )
      };

      this.buffer.push(entry);

      if (this.buffer.length >= this.BATCH_SIZE) {
        await this.flushToSupabase();
      }
    } catch (error) {
      console.error('Failed to log API call:', error);
      // Logging failures shouldn't break the API
    }
  }

  private calculateCost(inputTokens: number, outputTokens: number, model: keyof typeof this.PRICING): number {
    const rates = this.PRICING['gemini-2.5-flash'];
    const cost = ((inputTokens / 1_000_000) * rates.input) + ((outputTokens / 1_000_000) * rates.output);
    return cost;
  }

  private async flushToSupabase(): Promise<void> {
    if (this.buffer.length === 0) return;

    const batch = [...this.buffer];
    this.buffer = [];

    try {
      const { error } = await supabase.from('api_usage_logs').insert(batch);

      if (error) {
        console.error('Supabase insert error:', error);
        // Re-add to buffer for retry on next flush
        this.buffer.unshift(...batch);
      } else {
        console.info(`ðŸ“Š Logged ${batch.length} API calls to database`);
      }
    } catch (error) {
      console.error('Failed to flush logs to Supabase:', error);
      this.buffer.unshift(...batch);
    }
  }

  destroy(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    this.flushToSupabase(); // Final flush before exit
  }
}

export const apiLogger = new APILoggingService();


// Route-specific helpers for convenience

export const logChatCall = (data: {
    userId?: string;
    chatId: string;
    gradeLevel: number;
    message: string;
    responseText?: string;
    responseTimeMs: number;
    success: boolean;
    error?: string;
    usageMetadata?: any;
    model: string;
  }) => {
    return apiLogger.logAPICall({
      route: 'chat',
      inputText: data.message,
      outputText: data.responseText,
      geminiUsageMetadata: data.usageMetadata,
      ...data
    });
  };
  
  export const logLessonCall = (data: {
    userId?: string;
    gradeLevel: number;
    topic: string;
    responseText?: string;
    responseTimeMs: number;
    success: boolean;
    error?: string;
    usageMetadata?: any;
    model: string;
  }) => {
    return apiLogger.logAPICall({
      route: 'lesson',
      inputText: data.topic,
      outputText: data.responseText,
      geminiUsageMetadata: data.usageMetadata,
      ...data
    });
  };
  
  export const logStoryCall = (data: {
    userId?: string;
    gradeLevel: number;
    prompt: string;
    responseText?: string;
    responseTimeMs: number;
    success: boolean;
    error?: string;
    usageMetadata?: any;
    model: string;
  }) => {
    return apiLogger.logAPICall({
      route: 'story',
      inputText: data.prompt,
      outputText: data.responseText,
      geminiUsageMetadata: data.usageMetadata,
      ...data
    });
  }; 